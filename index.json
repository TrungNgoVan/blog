[{"content":"Hế lô, 🐳 Mình là Trung, hiện tại mình đang theo học cử nhân ngành Toán - Tin học, tại HCMUS.\nMình lập ra blog này để chia sẻ về những kiến thức, hiểu biết cũng như trải nghiệm của mình trong công việc và trong cuộc sống. Thú thật mình không giỏi viết, nhưng mong là nó ổn 🐧\nCảm ơn các bạn đã ghé thăm thế giới của mình 🌊\n","permalink":"https://TrungNgoVan.github.io/blog/docs/first-post/","summary":"Hế lô, 🐳 Mình là Trung, hiện tại mình đang theo học cử nhân ngành Toán - Tin học, tại HCMUS.\nMình lập ra blog này để chia sẻ về những kiến thức, hiểu biết cũng như trải nghiệm của mình trong công việc và trong cuộc sống. Thú thật mình không giỏi viết, nhưng mong là nó ổn 🐧\nCảm ơn các bạn đã ghé thăm thế giới của mình 🌊","title":"Bài viết đầu tiên"},{"content":"Interview Preparation for Python Developer Intern Operating System (OS) Question 1 Q: Bạn có thể giải thích sự khác nhau giữa process và thread không?\nA:\nProcess: Một tiến trình (process) là một chương trình đang chạy. Mỗi tiến trình có không gian địa chỉ riêng, bộ nhớ riêng và tài nguyên riêng. Tiến trình là đơn vị phân bổ tài nguyên của hệ điều hành. Thread: Một luồng (thread) là một đơn vị thực thi nhỏ hơn tiến trình. Các luồng trong cùng một tiến trình chia sẻ cùng một không gian địa chỉ và tài nguyên. Thread là đơn vị thực thi của tiến trình. Question 2 Q: Bạn đã từng làm việc với hệ điều hành Linux chưa? Nếu có, bạn hãy mô tả một vài lệnh cơ bản mà bạn thường sử dụng.\nA:\nLệnh cơ bản: ls: Liệt kê các file và thư mục trong thư mục hiện tại. cd: Thay đổi thư mục hiện tại. pwd: Hiển thị đường dẫn đầy đủ của thư mục hiện tại. cp: Sao chép file hoặc thư mục. mv: Di chuyển hoặc đổi tên file hoặc thư mục. rm: Xóa file hoặc thư mục. Question 3 Q: Bạn có thể giải thích cơ chế quản lý bộ nhớ (memory management) trong hệ điều hành không?\nA:\nQuản lý bộ nhớ: Bao gồm các cơ chế phân bổ và giải phóng bộ nhớ cho các tiến trình. Các kỹ thuật như phân đoạn (segmentation), phân trang (paging), và bộ nhớ ảo (virtual memory) được sử dụng để quản lý bộ nhớ hiệu quả và đảm bảo rằng mỗi tiến trình có không gian địa chỉ riêng biệt. Question 4 Q: Bạn hãy mô tả sự khác nhau giữa hệ điều hành đa nhiệm (multitasking) và đơn nhiệm (single-tasking).\nA:\nMultitasking: Hệ điều hành cho phép nhiều tiến trình chạy cùng một lúc bằng cách chia sẻ thời gian CPU giữa các tiến trình. Single-tasking: Hệ điều hành chỉ cho phép một tiến trình chạy tại một thời điểm. Các tiến trình phải chờ tiến trình hiện tại hoàn thành trước khi có thể bắt đầu. Network Question 1 Q: Bạn hãy giải thích các tầng của mô hình OSI.\nA:\nTầng 1: Physical (Vật lý): Truyền dữ liệu thô qua các phương tiện vật lý. Tầng 2: Data Link (Liên kết dữ liệu): Quản lý kết nối vật lý giữa hai thiết bị mạng. Tầng 3: Network (Mạng): Định tuyến dữ liệu từ nguồn đến đích. Tầng 4: Transport (Vận chuyển): Đảm bảo truyền dữ liệu một cách đáng tin cậy. Tầng 5: Session (Phiên): Quản lý các phiên kết nối giữa các ứng dụng. Tầng 6: Presentation (Trình bày): Chuyển đổi dữ liệu để truyền tải hoặc hiển thị. Tầng 7: Application (Ứng dụng): Cung cấp dịch vụ mạng cho ứng dụng. Question 2 Q: Bạn có thể mô tả cách hoạt động của HTTP/HTTPS không?\nA:\nHTTP: HyperText Transfer Protocol, giao thức truyền tải siêu văn bản, không mã hóa dữ liệu. HTTPS: HTTP Secure, phiên bản bảo mật của HTTP, sử dụng SSL/TLS để mã hóa dữ liệu truyền tải. Question 3 Q: Bạn hãy giải thích sự khác nhau giữa TCP và UDP.\nA:\nTCP (Transmission Control Protocol): Kết nối hướng (connection-oriented), đảm bảo truyền tải dữ liệu đáng tin cậy bằng cách kiểm tra lỗi, xác nhận nhận dữ liệu và phân đoạn dữ liệu. UDP (User Datagram Protocol): Không kết nối (connectionless), không đảm bảo truyền tải dữ liệu đáng tin cậy, không kiểm tra lỗi, không xác nhận nhận dữ liệu. UDP nhanh hơn TCP do ít overhead hơn. Question 4 Q: Bạn có thể mô tả cách hoạt động của DNS không?\nA:\nDNS (Domain Name System): Chuyển đổi tên miền (domain name) thành địa chỉ IP. Khi người dùng nhập tên miền vào trình duyệt, DNS resolver sẽ gửi truy vấn tới máy chủ DNS để lấy địa chỉ IP tương ứng và trả về cho trình duyệt. Database (DB) Question 1 Q: Bạn có thể giải thích sự khác nhau giữa SQL và NoSQL không?\nA:\nSQL: Cơ sở dữ liệu quan hệ (RDBMS) sử dụng ngôn ngữ SQL. Có cấu trúc bảng, dữ liệu được tổ chức theo hàng và cột. Phù hợp với dữ liệu có cấu trúc rõ ràng. NoSQL: Cơ sở dữ liệu phi quan hệ, không sử dụng ngôn ngữ SQL. Có thể là dạng key-value, document, column-family, hoặc graph. Phù hợp với dữ liệu không có cấu trúc hoặc bán cấu trúc. Question 2 Q: Bạn đã từng làm việc với các kỹ thuật tối ưu hóa truy vấn trong SQL chưa? Nếu có, hãy nêu một ví dụ.\nA:\nVí dụ: Sử dụng chỉ số (index) để tăng tốc độ truy vấn. Chỉ số giúp truy cập dữ liệu nhanh hơn bằng cách tạo ra cấu trúc dữ liệu phụ trợ. Question 3 Q: Bạn hãy giải thích các cấp độ cô lập (isolation levels) trong cơ sở dữ liệu.\nA:\nRead Uncommitted: Cho phép đọc dữ liệu chưa được commit, có thể dẫn đến dirty read. Read Committed: Chỉ cho phép đọc dữ liệu đã được commit, tránh dirty read nhưng có thể xảy ra non-repeatable read. Repeatable Read: Đảm bảo các lần đọc dữ liệu trong cùng một transaction là nhất quán, tránh non-repeatable read nhưng có thể xảy ra phantom read. Serializable: Cấp độ cao nhất, đảm bảo các transaction được thực thi tuần tự, tránh tất cả các loại lỗi nhưng hiệu năng thấp nhất. Question 4 Q: Bạn đã từng làm việc với các kỹ thuật sao lưu và phục hồi cơ sở dữ liệu chưa? Nếu có, hãy mô tả cách bạn thực hiện.\nA:\nSao lưu: Sử dụng các công cụ như pg_dump (PostgreSQL) hoặc mysqldump (MySQL) để tạo bản sao dữ liệu. Lên lịch sao lưu định kỳ để đảm bảo dữ liệu được bảo vệ. Phục hồi: Sử dụng bản sao lưu đã tạo để khôi phục dữ liệu. Thực hiện kiểm tra tính toàn vẹn và khôi phục dữ liệu vào cơ sở dữ liệu nếu cần thiết. Data Structures and Algorithms (DSA) Question 1 Q: Bạn có thể giải thích cách hoạt động của các cấu trúc dữ liệu như stack và queue không?\nA:\nStack: Cấu trúc dữ liệu kiểu LIFO (Last In, First Out). Phép toán chính là push (thêm phần tử vào đỉnh stack) và pop (loại bỏ phần tử từ đỉnh stack). Queue: Cấu trúc dữ liệu kiểu FIFO (First In, First Out). Phép toán chính là enqueue (thêm phần tử vào cuối queue) và dequeue (loại bỏ phần tử từ đầu queue). Question 2 Q: Bạn đã từng triển khai thuật toán sắp xếp nào chưa? Nếu có, hãy mô tả một thuật toán sắp xếp và cách hoạt động của nó.\nA:\nBubble Sort: So sánh từng cặp phần tử liền kề và hoán đổi nếu chúng không theo thứ tự. Lặp lại cho đến khi không còn cặp nào cần hoán đổi. Merge Sort: Chia danh sách thành hai nửa, sắp xếp từng nửa và sau đó hợp nhất hai nửa đã sắp xếp. Question 3 Q: Bạn có thể giải thích cách hoạt động của cây nhị phân tìm kiếm (Binary Search Tree) không?\nA:\nBST: Mỗi node có tối đa hai con, với giá trị của node con trái nhỏ hơn node gốc và giá trị của node con phải lớn hơn node gốc. Điều này cho phép tìm kiếm, chèn, và xóa phần tử hiệu quả. Question 4 Q: Bạn đã từng làm việc với đồ thị (graph) chưa? Nếu có, hãy mô tả một thuật toán duyệt đồ thị mà bạn biết.\nA:\nBreadth-First Search (BFS): Duyệt đồ thị theo chiều rộng, sử dụng hàng đợi (queue) để theo dõi các node đã được khám phá. Bắt đầu từ node gốc, lần lượt khám phá các node kề của nó trước khi chuyển sang các node ở mức độ sâu hơn. Web Development Interview Questions and Answers Single Page Application (SPA) Q: Bạn có thể giải thích cách hoạt động của một ứng dụng Single Page Application (SPA) không?\nA: SPA là ứng dụng web tải về một lần và tương tác với người dùng bằng cách tải nội dung động. SPA sử dụng AJAX và JavaScript để cập nhật nội dung mà không cần tải lại trang. Một số ví dụ về SPA là các framework và thư viện như React, Angular.\nFrontend Build Tools Q: Bạn đã từng làm việc với các công cụ build frontend như Webpack hoặc Gulp chưa? Nếu có, hãy mô tả cách bạn sử dụng chúng.\nA:\nWebpack: Là một module bundler cho JavaScript. Webpack dùng để gộp các module thành một hoặc nhiều file tĩnh để dễ dàng quản lý và tối ưu hóa. Gulp: Là một task runner, dùng để tự động hóa các nhiệm vụ như nén ảnh, chuyển đổi SASS/LESS thành CSS, và thực hiện các tác vụ khác trong quá trình phát triển. Version Control Q: Bạn có thể giải thích cách sử dụng Git để quản lý mã nguồn không?\nA:\nCơ bản: Sử dụng các lệnh như git init để khởi tạo kho lưu trữ, git clone để sao chép kho lưu trữ, git add để thêm thay đổi vào staging, git commit để lưu thay đổi, git push để đẩy thay đổi lên server, và git pull để lấy thay đổi từ server về. Branching: Sử dụng git branch để tạo nhánh mới, git checkout -b để tạo và chuyển đến nhánh mới, và git merge để hợp nhất các nhánh. CI/CD Pipeline Q: Bạn đã từng làm việc với các hệ thống CI/CD chưa? Nếu có, hãy mô tả cách bạn thiết lập một pipeline CI/CD.\nA:\nCI/CD: Continuous Integration and Continuous Deployment. Sử dụng các công cụ như Jenkins, Travis CI, hoặc GitLab CI để thiết lập các bước build, test, và deploy tự động mỗi khi có thay đổi mã nguồn. Điều này giúp đảm bảo rằng ứng dụng luôn được kiểm thử và triển khai một cách nhất quán và hiệu quả. Testing in Web Development Q: Bạn có thể giải thích sự khác nhau giữa kiểm thử đơn vị (unit testing) và kiểm thử tích hợp (integration testing) không?\nA:\nUnit testing: Kiểm thử các thành phần nhỏ nhất của ứng dụng, như hàm hoặc phương thức, một cách độc lập để đảm bảo rằng chúng hoạt động đúng. Integration testing: Kiểm thử sự kết hợp của các thành phần để đảm bảo rằng chúng hoạt động đúng khi kết hợp với nhau. Security in Web Development Q: Bạn có thể giải thích các biện pháp bảo mật cơ bản cho một ứng dụng web không?\nA:\nXSS (Cross-Site Scripting): Lọc và mã hóa đầu vào người dùng để ngăn chặn mã độc được thực thi trên trình duyệt của người dùng. CSRF (Cross-Site Request Forgery): Sử dụng token CSRF để xác thực các yêu cầu từ người dùng. SQL Injection: Sử dụng prepared statements và ORM (Object-Relational Mapping) để ngăn chặn việc chèn mã SQL độc hại vào các truy vấn cơ sở dữ liệu. Data Encryption Q: Bạn đã từng làm việc với các kỹ thuật bảo mật như mã hóa dữ liệu chưa? Nếu có, hãy mô tả cách bạn thực hiện.\nA: Mã hóa: Sử dụng các thư viện như cryptography trong Python để mã hóa và giải mã dữ liệu. Ví dụ, sử dụng AES (Advanced Encryption Standard) để mã hóa dữ liệu nhạy cảm trước khi lưu trữ hoặc truyền tải.\n","permalink":"https://TrungNgoVan.github.io/blog/docs/preparation_for_python_developer_intern/","summary":"Interview Preparation for Python Developer Intern Operating System (OS) Question 1 Q: Bạn có thể giải thích sự khác nhau giữa process và thread không?\nA:\nProcess: Một tiến trình (process) là một chương trình đang chạy. Mỗi tiến trình có không gian địa chỉ riêng, bộ nhớ riêng và tài nguyên riêng. Tiến trình là đơn vị phân bổ tài nguyên của hệ điều hành. Thread: Một luồng (thread) là một đơn vị thực thi nhỏ hơn tiến trình.","title":"Interview Preparation for Python Developer Intern"},{"content":"Hế lô mọi người Long time no see 🐳 Lâu lắm rồi mình mới quay lại viết blog 🐳 Dạo gần đây mình bận ôn thi trên trường và làm 1 vài dự án freelancer bên ngoài. Mọi thứ có vẻ ổn, ít nhất là đến hiện tại 😀\nThời tới 😈 Mới đây mình sau khi chạy deadline xong, khá rảnh nên lọ mọ đi kiếm chỗ apply intern. Lần này mình lên Vietnamework để tìm việc. Đây cũng là lần đầu mình dùng nền tảng này, lên cũng làm hồ sơ qua qua rồi đọc xem có uy tín không. Xem xét 1 lúc thì mình search ra 3 offer cho vị trí Backend Intern mà mình đang tìm kiếm.\nVì tay nhanh hơn não 😀 Nên mình làm hồ sơ, sửa CV và apply luôn không nghĩ nhiều. Một phần vì hiện tại và tương lai gần mình khá là rảnh nên muốn tìm việc làm. Bất ngờ là ngay ngày mình biết đến Vietnamework, cũng là ngày mà công ty mình apply đăng bài tuyển. Người ta nói mà, \u0026ldquo;hay không bằng hên\u0026rdquo;.\nCuộc gọi bất ngờ 📱 Sau khi apply vài ngày thì mình được chị HR gọi xác nhận và mời qua công ty phỏng vấn 🐳 Lần đầu mình được HR gọi, xong cảm giác cũng lạ lắm. Kiểu vui vì được gọi đi phỏng vấn nhưng cũng lo lắng vì lịch phỏng vấn hơi sát, nhưng vẫn vui hơn lo nha.\nTất cả mọi thứ xảy đến đúng bất ngờ á, tự dưng rảnh ngồi tìm việc, thấy job xong apply. Chuẩn bị đi chạy bộ thì có người gọi, bắt máy xong thì biết mình được gọi phỏng vấn. Ão thật đấy 😀\nHành trình đi phỏng vấn của tui 🐳 Lần đầu mình đi phỏng vấn ở 1 công ty 😟 Cảm giác lo lắng là rõ. Lịch phỏng vấn được hẹn là 16h nhưng mình đã bắt đầu đi từ 14h30\u0026rsquo; rồi. Chỗ mình ở qua công ty cũng xa, tầm 20km á. Đợt đấy đi tầm 50\u0026rsquo; là tới nơi rồi. 😀 Không phải chậm đâu, vừa đi vừa nghe chị Google đọc map mà, chứ có biết đường đâu. Sợ GPS load không kịp xong nó chỉ đi lạc xong trễ giờ cái thì mất hết.\nSau bao gian nan thì cũng tới được công ty, kết quả là tới sớm tận 40\u0026rsquo; 😀 Mình đi mượt quá nên đúng số phút trên map báo luôn. Lên tới công ty thì mình có gọi cho chị HR ra đón, chị thấy mình tới sớm quá nên dẫn mình xuống dưới lại và mua nước cho uống 🥰 Lần nữa cảm ơn chị vì ly nước.\nTrao đổi với chị được 1 lúc thì tới giờ nên mình lên và vào phỏng vấn luôn. Ban đầu là ra ban công nói chuyện với anh CTO của công ty (vì phòng họp lúc đó bận không dùng được). Run run và run. Cái gì quan trọn nhắc 3 lần 😀. Mình rất run khi gặp anh CTO, mặc dù ở ban công thoáng mát nhưng vẫn run. Anh CTO rất vui tính, giới thiệu 1 lúc thì cũng bắt đầu buổi phỏng vấn.\nAnh CTO vừa đọc CV của mình, vừa hỏi các mục trong đó. Đầu tiên là về các kiến thức mình list ra trong CV, leval sử dúng các kiến thức đó ở mức nào. Rồi đến các projects mình làm, cái này anh hỏi khá kỹ và khai thác vào CV của mình rất nhiều. Nên là nếu các bạn đang chuẩn bị xin intern thì nên đầu tư vào mục này trong CV nha.\nSau khi trao đổi được 1 lúc thì mình di chuyển vào phòng họp để thuận tiện hơn. Ở đây mình được anh CTO đưa ra 1 vài đoạn code \u0026ldquo;magic\u0026rdquo; trong Javascript. Tất nhiên là mình đã trả lời sai khi anh hỏi về các đoạn code \u0026ldquo;magic\u0026rdquo; đó 😀 Mình gà. Cuối cùng anh CTO cho mình 1 câu giải thuật để kiểm tra mindset cũng như kiến thức về DSA của mình như nào. Đề bài khá đơn giản, và mình đã làm được 🐳. Tuyệt vời luôn. Sau khi hoàn thành bài đó thì mình cũng kết thúc phỏng vấn với anh CTO và gặp chị HR để thảo luận 1 vài cái liên quan. Cuối cùng sau 1 giờ phỏng vấn thì mình ra về với tâm trạng nhẹ nhõm, thoải mái vì mình không mắc sai lầm nào trong lúc phỏng vấn cả 🐧 Mong là thế.\nChút chia sẻ ⭐️ Trong lúc phỏng vấn mình để ý anh CTO khai thác nhiều vào phần projects và không đặt nặng ngôn ngữ lập trình, như mình hiện tại là chuyện Nodejs còn công ty lại đang dùng Python. Mình nghĩ các bạn nên đầu tư vào các dự án các bạn làm, và hiểu về nó sâu nhất có thể. Các anh phỏng vấn có thể rất giỏi và đã làm qua các dự án đó nên khi họ nhìn vào sẽ biết hỏi gì để kiểm tra bạn có thật sự hiểu những gì bạn làm hay không đó 🐳\nKết 🎬 Sau ngày phỏng vấn 1 hôm thì mình đã nhận được kết quả từ chị HR,\u0026hellip; Mình đã pass và được chọn vào vị trí Backend Intern tại công ty với mức lương dưới 1 tỷ.\nĐây là lần đầu mình đi phỏng vấn và cũng là lần đầu mình đi làm công ty. Mình đang tò mò thời gian tới sẽ như thế nào. Nếu ổn mình sẽ quay lại đây và kể với mọi người.\nCảm ơn và hẹn gặp lại 🐳\n","permalink":"https://TrungNgoVan.github.io/blog/docs/first-interview-backend-intern/","summary":"Hế lô mọi người Long time no see 🐳 Lâu lắm rồi mình mới quay lại viết blog 🐳 Dạo gần đây mình bận ôn thi trên trường và làm 1 vài dự án freelancer bên ngoài. Mọi thứ có vẻ ổn, ít nhất là đến hiện tại 😀\nThời tới 😈 Mới đây mình sau khi chạy deadline xong, khá rảnh nên lọ mọ đi kiếm chỗ apply intern. Lần này mình lên Vietnamework để tìm việc.","title":"Lần đầu phỏng vấn vị trí Backend Intern"},{"content":"Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃\nThế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:\nChuỗi \u0026ldquo;cabadabac\u0026rdquo; là 1 palindrome. Vì chuỗi này đối xứng qua ký tự \u0026rsquo;d\u0026rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi \u0026ldquo;acbaabca\u0026rdquo; cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự \u0026lsquo;a\u0026rsquo;.\nĐể dễ hình dung hơn, các bạn có thể tưởng tưởng 1 palindrome được tạo ra bằng cách phản chiếu 1 chuỗi ký tự qua \u0026ldquo;gương\u0026rdquo;.\nVậy sub-palindromes (còn gọi là palindrome substrings) là các chuỗi con của một chuỗi ban đầu và là palindrome.\nTheo mình tìm hiểu thì sub-palindromes là một khái niệm quan trọng trong xử lý chuỗi và có ứng dụng trong nhiều bài toán, bao gồm tìm kiếm từ, mã hóa, nén dữ liệu và xử lý ngôn ngữ tự nhiên. Trong bài viết này mình sẽ nói đến 1 bài toán khá hay. Go go 🐳\nBài toán: Tìm tất cả các sub-palindromes trong thời gian $O(n)$ Bài toán Cho chuỗi $s$ với độ dài $n$ . Tìm tất cả các cặp $(i, j)$ sao cho chuỗi con $s[i\\dots j]$ là một chuỗi đối xứng. Chuỗi $t$ là một chuỗi đối xứng khi $t = t_{rev}$ ( $t_{rev}$ là một chuỗi đảo ngược của $t$ ).\nPhân tích Chuỗi đối xứng ở đây chính là palindrome mình đã đề cập ở trên.\nTrong trường hợp xấu nhất, chuỗi ban đầu có thể có tới $O(n^2)$ chuỗi con đối xứng. Lúc đầu mình nhìn qua thì nghĩ là không có thuật toán tuyến tính nào cho bài toán này. Tức là sẽ không có bài viết này 👀\nPhân tích kỹ hơn 🔎: Các palindrome sẽ có độ dài lẻ và chẵn khác nhau, và được tính riêng là $d_{odd}[i]$ và $d_{even}[i]$ . Đối với các palindrome có độ dài chẵn, chúng ta giả định rằng chúng có tâm ở vị trí $i$ nếu hai ký tự trung tâm của chúng là $s[i]$ và $s[i-1]$ .\nVí dụ, chuỗi $s = abababc$ có 3 palindromes có độ dài lẻ với tâm ở vị trí $s[3] = b$ , tức là $d_{odd}[3] = 3$ :\na \u0026#xA0; b \u0026#xA0; a \u0026#xA0; b \u0026#x23DF; s 3 \u0026#xA0; a \u0026#xA0; b \u0026#x23DE; d o d d [ 3 ] = 3 c Và chuỗi $s = cbaabd$ có 2 palindromes có độ dài bằng nhau với tâm ở vị trí $s[3] = a$ , tức là $d_{even}[3] = 2$ :\nc \u0026#xA0; b \u0026#xA0; a \u0026#xA0; a \u0026#x23DF; s 3 \u0026#xA0; b \u0026#x23DE; d e v e n [ 3 ] = 2 d Thực tế, vấn đề này đã có nhiều giải pháp: với String Hashing, nó có thể được giải quyết trong $O(n\\cdot \\log n)$ , và với Suffix Trees và Fast LCA , vấn đề này có thể được giải quyết trong $O(n)$ . Các bạn có thể tự tìm hiểu.\nNhưng thuật toán mình nói trong đến trong bài này đơn giản hơn và có ít hằng số ẩn hơn về độ phức tạp của bộ nhớ và thời gian. Thuật toán này được phát hiện bởi Glenn K. Manacher vào năm 1975.\nVề ý tưởng cốt lõi là tính toán số lượng palindrome hiện tại dựa trên thông tin palindrome được tính toán trước đó. Nghe giống DP nhỉ 👀\nCode thôi 💻 Động não 🤔 Để xử lý vấn đề palindrome có độ dài lẻ và chẵn khác nhau, thay vì tính toán cho cả 2 trường hợp. Chúng ta sẽ biến đổi chuỗi ban đầu 1 chút. Cụ thể, mình sẽ thêm ký tự # vào đầu, cuối và giữa các ký tự của chuỗi ban đầu. Trông nó sẽ như vậy:\nSau khi modify chuỗi, chúng ta sẽ luôn thu được 1 chuỗi mới có độ dài lẻ. Và sẽ không có trường hợp palindrome có độ dài chẵn tạo bởi các ký tự trong chuỗi ban đầu.\nBởi vì giữa chúng luôn có ký tự \u0026rsquo;#\u0026rsquo;. Do đó chúng ta đã bỏ qua được vấn đề phải tính toán số lượng các palindromes có độ dài chẵn.\nVậy giờ mình chỉ cần tìm số lượng các palindrome lẻ và lưu lại. 👀 Nghe dễ nhỉ\nThuật toán \u0026ldquo;ngây thơ\u0026rdquo; Khởi tạo một biến đếm tên res để theo dõi số lượng xâu đối xứng. Tạo một chuỗi bắt đầu bằng \u0026lsquo;^\u0026rsquo; và kết thúc bằng \u0026lsquo;$\u0026rsquo; là newS được tạo bằng cách chèn ký tự # giữa mỗi ký tự của chuỗi đầu vào s. Tạo mảng p[] đại diện cho $d_{odd}[]$ Lặp lại từng chỉ số $i$ của chuỗi được sửa đổi newS. Đối với mỗi chỉ số $i$, khởi tạo các biến l và r bằng 1, và p[i] bằng 0. Thực hiện vòng lặp while khi các ký tự tại các chỉ số $i - l$ và $i + r$ hợp lệ và bằng nhau. Vòng lặp này mở rộng xâu đối xứng được tập trung tại chỉ số i và đếm số lượng xâu đối xứng. Bên trong vòng lặp, tăng p[i] lên 1 và cập nhật l và r bằng cách tăng chúng lên 1. Sau khi vòng lặp while kết thúc, thêm Math.ceil(p[i] / 2) vào res. Điều này là vì mỗi chuỗi đối xứng hợp lệ được tính hai lần (một lần cho độ dài lẻ và một lần cho độ dài chẵn), vì vậy chúng ta chia p[i] cho 2 và lấy giá trị làm tròn của nó. Lặp lại các bước 4-7 cho tất cả các chỉ số $i$ của chuỗi được sửa đổi newS. Cuối cùng, trả về giá trị của res, đại diện cho tổng số lượng xâu đối xứng trong chuỗi ban đầu s. Mình dùng Javascript để code bài này:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var SubPalindromes = function (s) { let res = 0; let newS = \u0026#34;^#\u0026#34;; for (let i = 0; i \u0026lt; s.length; i++) { newS += s[i] + \u0026#34;#\u0026#34;; } newS += \u0026#34;$\u0026#34;; let n = newS.length, l, r, count; let p = new Array(n).fill(0); for (let i = 1; i \u0026lt; n - 1; i++) { p[i] = 0; l = 1; r = 1; while (i - l \u0026gt;= 0 \u0026amp;\u0026amp; i + r \u0026lt; n \u0026amp;\u0026amp; newS[i - l] == newS[i + r]) { p[i]++; l++; r++; } res += Math.ceil(p[i] / 2); } return res; }; Độ phức tạp Thời gian: $O(n^2)$, trong đó n là độ dài của chuỗi đầu vào s. Thuật toán lặp qua từng ký tự của chuỗi đã sửa đổi được xử lý và đối với mỗi ký tự, nó mở rộng bảng màu ở cả hai bên. Trong trường hợp xấu nhất, mỗi ký tự của newS có thể là trung tâm của một palindrome, dẫn đến các lần lặp O(n^2). Không gian: $O(n)$, trong đó n là độ dài của chuỗi đầu vào s. Chuỗi đã sửa đổi processS yêu cầu thêm dung lượng O(n) để lưu trữ phiên bản đã sửa đổi. Thuật toán Manacher\u0026rsquo;s 🐳 Với thuật tóa này, mình sẽ duy trì cặp biên $(l, r)$ của palindrome dài nhất hiện tại (tức sub-palindromes của s dài nhất bắt đầu từ $s[l+1]$ và kết thúc tại $s[r-1]$). Ban đầu, ta thiết lập $l = 0, r = 1$ , tương ứng với chuỗi rỗng. (Để gọn thì mình sẽ gọi \u0026ldquo;palindrome dài nhất hiện tại\u0026rdquo; là maxPalindrome)\nBây giờ, chúng ta cần tính toán $d_{odd}[i]$, trong đó tất cả các giá trị trước đó trong $d_{odd}[]$ đã được tính toán. Thuật toán trông như sau:\nNếu $i$ không thuộc maxPalindrome, tức là $i \\geq r$, chúng ta sẽ thực hiện tương tự thuật toán \u0026ldquo;Ngây thơ\u0026rdquo; ở trên.\nCụ thể, chúng ta sẽ tăng lần lượt $d_{odd}[i]$ và mỗi lần sẽ kiểm tra xem chuỗi con $[i - d_{odd}[i]\\dots i + d_{odd}[i]]$ có phải là một palindrome hay không. Nếu không hoặc vượt quá chuỗi $s$, chúng ta sẽ dừng lại. Sau khi kết thúc, mình tính đươc $d_{odd}[i]$ và lưu lại. Cuối cùng, mình sẽ cập nhật maxPalindrome $(l, r)$. Bước này khá đơn giản, nên tự làm nhé 👀\nBây giờ, xét trường hợp khi $i \\lt r$. Mình sẽ tìm vị trí \u0026ldquo;đối xứng\u0026rdquo; của $i$ trong maxPalindrome $(l, r)$, tức là sẽ lấy vị trí $j = l + (r - i)$ và lấy giá trị của $d_{odd}[j]$. Vì $j$ là vị trí đối xứng với $i$ qua tâm $(l+r)/2$, mình có thể gán $d_{odd}[i] = d_{odd}[j]$. Giải thích cho điều này (palindrome tâm $j$ thực sự được \u0026ldquo;sao chép\u0026rdquo; vào palindrome tâm $i$):\n\u0026#x2026; \u0026#xA0; s l + 1 \u0026#xA0; \u0026#x2026; \u0026#xA0; s j \u0026#x2212; d o d d [ j ] + 1 \u0026#xA0; \u0026#x2026; \u0026#xA0; s j \u0026#xA0; \u0026#x2026; \u0026#xA0; s j + d o d d [ j ] \u0026#x2212; 1 \u0026#xA0; \u0026#x23DF; palindrome tâm j \u0026#xA0; \u0026#x2026; \u0026#xA0; s i \u0026#x2212; d o d d [ j ] + 1 \u0026#xA0; \u0026#x2026; \u0026#xA0; s i \u0026#xA0; \u0026#x2026; \u0026#xA0; s i + d o d d [ j ] \u0026#x2212; 1 \u0026#xA0; \u0026#x23DF; palindrome tâm i \u0026#xA0; \u0026#x2026; \u0026#xA0; s r \u0026#x2212; 1 \u0026#xA0; \u0026#x23DE; maxPalindrome \u0026#xA0; \u0026#x2026; Cách này đã giảm đi khá nhiều độ phức tạp, thay vì mình phải tính $d_{odd}[i]$, mình sẽ dùng lại $d_{odd}[j]$ đã tính trước đó thông qua tính chất đối xứng, đơn giản ha 🐧\nNhưng có một trường hợp đặc biệt: khi palindrome đang xét thuộc maxPalindrome nhưng vượt quá biên của nó, tức là $j - d_{odd}[j] \\le l$ (hoặc $i + d_{odd}[j] \\ge r$ ). Mình sẽ không chắc chắn được lúc này $d_{odd}[i]$ có bằng $d_{odd}[j]$ hay không ? Vì đã vượt ra ngoài maxPalindrome, mà chúng ta chỉ kiếm soát được sự đối xứng bên trong maxPalindrome thôi 🐧.\nĐể xử lý thì lúc đó mình sẽ đặt $d_{odd}[i] = r - i$. Sau đó, sẽ chạy thuật toán \u0026ldquo;Ngây thơ\u0026rdquo; để cố gắng tăng $d_{odd}[i]$. Cách này vẫn sẽ giúp chúng ta giảm bớt được 1 khoảng nào đó khi tính toán $d_{odd}[i]$ so với việc \u0026ldquo;Ngây thơ\u0026rdquo; từ đầu. 👀\nCuối cùng vẫn không quên cập nhật maxPalindrome $(l, r)$\nSau khi kết thúc quá trình tính toán, việc còn lại đơn giản là trả về tổng của $d_{odd}[]$ để có được tổng sub-palindromes.\nMình code bằng Javascript, vì trong bài này, vai trò của $l$ và $r$ giống nhau (vì tính đối xứng) và mình không dùng tới $l$ nên không đưa vào cho đơn giản 🐳\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let SubPalindromes = function (s) { let n = s.length; let newS = \u0026#34;^#\u0026#34;; for (let i = 0; i \u0026lt; n; i++) { newS += s[i] + \u0026#34;#\u0026#34;; } newS += \u0026#34;$\u0026#34;; let p = new Array(newS.length).fill(0); let center = 0, r = 0; for (let i = 1; i \u0026lt; newS.length - 1; i++) { let mirror = 2 * center - i; if (i \u0026lt; r) { p[i] = Math.min(r - i, p[mirror]); } while (newS[i + p[i] + 1] == newS[i - p[i] - 1]) { p[i]++; } if (i + p[i] \u0026gt; r) { center = i; r = i + p[i]; } } let result = p.reduce((a, b) =\u0026gt; a + Math.floor((b + 1) / 2)); return result; }; Độ phức tạp Thoạt nhìn, không rõ ràng là thuật toán này có độ phức tạp thời gian tuyến tính, bởi vì mình đã chạy thuật toán \u0026ldquo;Ngây thơ\u0026rdquo; trong khi chạy thuật toán Manacher\u0026rsquo;.\nTuy nhiên, các bạn có thể thấy rằng mỗi lần lặp lại thuật toán \u0026ldquo;Ngây thơ\u0026rdquo; đều tăng $r$ ít nhất là 1 đơn vị. Và $r$ không thể giảm trong thuật toán. Vì vậy, thuật toán \u0026ldquo;Ngây thơ\u0026rdquo; sẽ tăng $r$ n lần hay tổng số lần lặp là $O(n)$ .\nCác phần khác của thuật toán Manacher\u0026rsquo;s hoạt động rõ ràng trong thời gian tuyến tính. Như vậy, mình nhận được độ phức tạp về thời gian là $O(n)$.\n","permalink":"https://TrungNgoVan.github.io/blog/docs/manacher-algorithm/","summary":"Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃\nThế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:\nChuỗi \u0026ldquo;cabadabac\u0026rdquo; là 1 palindrome. Vì chuỗi này đối xứng qua ký tự \u0026rsquo;d\u0026rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi \u0026ldquo;acbaabca\u0026rdquo; cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự \u0026lsquo;a\u0026rsquo;.","title":"Manacher's Algorithm"},{"content":" Chào bạn! Mình là Trung 🐳 bạn có thể gọi mình là Henry, một sinh viên Đại học Khoa học Tự nhiên - Đại học Quốc gia TPHCM.\nMình tạo ra blog này để chia sẻ những kinh nghiệm, kiến thức về nhiều chủ đề khác nhau trong công việc và cuộc sống. Mình không giỏi viết nhưng mong là sẽ ổn 👀\nMình có niềm đam mê với toán học và máy tính 💻. Chính đam mê này mình đã quyết định theo học chuyên ngành Toán - Tin học tại trường đại học hiện tại. Điều này cho phép mình khám phá sâu hơn về cả hai lĩnh vực này. Hiện tại, mình đang học năm thứ hai và rất thích thú với những gì mình đã và đang tìm hiểu.\nNgoài việc học tập và công việc, mình cũng thích đọc sách 📖 về công nghệ và lập trình. Mình thấy nó thú vị khi tìm hiểu về các xu hướng và tiến bộ mới nhất trong lĩnh vực này. Và khi có thời gian rảnh rỗi, mình cũng thích chơi game 🎮 và xem phim.\nĐó là một chút về mình! Nếu bạn có bất kỳ câu hỏi hoặc chỉ muốn nói chuyện, hãy liên hệ với mình qua email.\nCảm ơn bạn đã ghé qua 🐳\n","permalink":"https://TrungNgoVan.github.io/blog/about/","summary":"Chào bạn! Mình là Trung 🐳 bạn có thể gọi mình là Henry, một sinh viên Đại học Khoa học Tự nhiên - Đại học Quốc gia TPHCM.\nMình tạo ra blog này để chia sẻ những kinh nghiệm, kiến thức về nhiều chủ đề khác nhau trong công việc và cuộc sống. Mình không giỏi viết nhưng mong là sẽ ổn 👀\nMình có niềm đam mê với toán học và máy tính 💻.","title":"Một chút về mình 🐳"}]